// nexus_core.h - Nexus Runtime Core Header File
// This file provides runtime support for transpiled Nexus code
// DO NOT EDIT - This file is automatically generated

#ifndef NEXUS_CORE_H
#define NEXUS_CORE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ============================================================================
// Type Tags for Runtime Type Information
// ============================================================================

typedef enum {
    NX_TYPE_I64,
    NX_TYPE_I32,
    NX_TYPE_U64,
    NX_TYPE_U32,
    NX_TYPE_F64,
    NX_TYPE_F32,
    NX_TYPE_BOOL,
    NX_TYPE_STRING,
    NX_TYPE_ARRAY,
    NX_TYPE_UNKNOWN,
    NX_TYPE_INTERFACE,
} nx_type_tag;

// Forward declarations for structs
typedef struct nx_array nx_array;
typedef struct nx_string nx_string;
typedef struct nx_interface_value nx_interface_value;

// ============================================================================
// Tagged Value Type
// ============================================================================

typedef struct {
    nx_type_tag tag;
    union {
        int64_t as_i64;
        int32_t as_i32;
        uint64_t as_u64;
        uint32_t as_u32;
        double as_f64;
        float as_f32;
        bool as_bool;
        nx_string* as_string;
        nx_array* as_array;
        void* as_ptr;
        nx_interface_value* as_interface;
    } data;
} nx_value;

// ============================================================================
// Interface Runtime Support (Dynamic Dispatch via VTables)
// ============================================================================

// Base vtable structure - all interface vtables start with this
typedef struct {
    const char* interface_name;
    const char* concrete_type_name;
} nx_vtable_base;

// Interface value wrapper - holds concrete data + vtable pointer
// This is used when storing interface-typed values (e.g., in [dyn]Interface arrays)
struct nx_interface_value {
    void* data;                  // Pointer to heap-allocated concrete struct
    size_t data_size;            // Size of the concrete struct
    nx_vtable_base* vtable;      // Pointer to the vtable for this concrete type
};

// Create a new interface value by wrapping a concrete struct
// The concrete struct is copied to the heap
nx_interface_value* nx_interface_wrap(void* concrete_data, size_t data_size, nx_vtable_base* vtable);

// Get the concrete data from an interface value (for field access)
void* nx_interface_unwrap(nx_interface_value* iface);

// Get the vtable from an interface value
nx_vtable_base* nx_interface_get_vtable(nx_interface_value* iface);

// Free an interface value (frees the copied data)
void nx_interface_free(nx_interface_value* iface);

// Create an interface value on the stack (for temporary use)
nx_interface_value nx_interface_wrap_stack(void* concrete_data, size_t data_size, nx_vtable_base* vtable);

// ============================================================================
// Memory Management
// ============================================================================

// Allocate memory with error checking
void* nx_malloc(size_t size);

// Reallocate memory with error checking
void* nx_realloc(void* ptr, size_t size);

// Free memory
void nx_free(void* ptr);

// ============================================================================
// Dynamic Arrays
// ============================================================================

// Dynamic array structure (full definition)
struct nx_array {
    void* data;
    size_t len;
    size_t cap;
    size_t elem_size;
};

// Create a new dynamic array
nx_array nx_array_new(size_t elem_size);

// Create a new dynamic array with capacity
nx_array nx_array_with_capacity(size_t elem_size, size_t capacity);

// Push an element to the array
void nx_array_push(nx_array* arr, const void* elem);

// Push an element with explicit size (reinitializes array elem_size on first push if needed)
void nx_array_push_sized(nx_array* arr, const void* elem, size_t elem_size);

// Pop an element from the array
bool nx_array_pop(nx_array* arr, void* out_elem);

// Get an element with bounds checking
void* nx_array_get_checked(nx_array* arr, size_t index);

// Get the length of an array
size_t nx_array_len(nx_array* arr);

// Free an array
void nx_array_free(nx_array* arr);

// Create array from literal data (makes a copy)
nx_array nx_array_from_literal(const void* data, size_t len, size_t elem_size);

// Concatenate two arrays into a new array
nx_array nx_array_concat(nx_array* a, nx_array* b);

// Slice an array from start to end (exclusive) into a new array
nx_array nx_array_slice(nx_array* arr, size_t start, size_t end);

// ============================================================================
// Strings (arrays of runes/chars)
// ============================================================================

// String structure (array of UTF-32 code points, full definition)
struct nx_string {
    uint32_t* data;
    size_t len;
    size_t cap;
};

// Create a new string from C string
nx_string nx_string_from_cstr(const char* cstr);

// Convert string to C string (UTF-8)
char* nx_string_to_cstr(nx_string* str);

// Get string length
size_t nx_string_len(nx_string* str);

// Free a string
void nx_string_free(nx_string* str);

// Concatenate two strings (takes pointers to avoid copy issues)
nx_string nx_string_concat(nx_string* a, nx_string* b);

// Convert a typed value to string (recursive for arrays)
nx_string nx_string_from_value(nx_value val);

// ============================================================================
// Unknown/Sum Types
// ============================================================================

// Unknown type representation (tagged union)
typedef struct {
    size_t variant_index;
    void* value;
    size_t value_size;
} nx_unknown;

// Create an unknown value
nx_unknown nx_unknown_new(size_t variant_index, const void* value, size_t value_size);

// Get the variant index
size_t nx_unknown_variant(nx_unknown* u);

// Get the value (must cast to correct type)
void* nx_unknown_value(nx_unknown* u);

// Free an unknown value
void nx_unknown_free(nx_unknown* u);

// ============================================================================
// Error Handling
// ============================================================================

// Panic with a message and exit
void nx_panic(const char* message);

// Check bounds and panic if out of range
void nx_bounds_check(size_t index, size_t len, const char* context);

// ============================================================================
// Compat I/O Functions
// ============================================================================

// Print an array of typed values to stdout
void nx_compat_print(nx_value* values, size_t count);

// Print an array of typed values to stdout with newline
void nx_compat_println(nx_value* values, size_t count);

// Read a line from stdin
nx_string nx_compat_readln(void);

// Parse a string to i64
int64_t nx_compat_parse_i64(nx_string* s);

// Split a string by delimiter
nx_array nx_compat_split(nx_string* s, nx_string* delimiter);

// Trim whitespace from string
nx_string nx_compat_trim(nx_string* s);

// Check if string starts with prefix
bool nx_compat_starts_with(nx_string* s, nx_string* prefix);

// Check if string ends with suffix
bool nx_compat_ends_with(nx_string* s, nx_string* suffix);

// Check if string is empty
bool nx_compat_is_empty(nx_string* s);

// Check if array is empty
bool nx_compat_is_empty_array(nx_array* arr);

// Join array of strings with delimiter
nx_string nx_compat_join(nx_array* arr, nx_string* delimiter);

// Compare two strings for equality
bool nx_compat_eqs(nx_string* a, nx_string* b);

// ============================================================================
// Std Builtin Functions (always available, no import needed)
// ============================================================================

// Parse a string to i64
int64_t nx_builtin_parse_i64(nx_string s);

// Split a string by delimiter
nx_array nx_builtin_split(nx_string s, nx_string delimiter);

// Trim whitespace from string
nx_string nx_builtin_trim(nx_string s);

// Check if string starts with prefix
bool nx_builtin_starts_with(nx_string s, nx_string prefix);

// Check if string ends with suffix
bool nx_builtin_ends_with(nx_string s, nx_string suffix);

// Check if string is empty
bool nx_builtin_is_empty(nx_string s);

// Join array of strings with delimiter
nx_string nx_builtin_join(nx_array arr, nx_string delimiter);

// Compare two strings for equality
bool nx_builtin_eqs(nx_string a, nx_string b);

// Get command line arguments (std builtin version)
nx_array nx_getargs(void);

// Read file contents (takes nx_string path)
nx_string nx_read_file(nx_string path);

// Read entire file contents
nx_string nx_compat_read_file(const char* path);

// Write string to file
bool nx_compat_write_file(const char* path, const char* content);

// Check if file exists
bool nx_compat_file_exists(const char* path);

// ============================================================================
// Compat Time Functions
// ============================================================================

// Get current time in milliseconds since epoch
int64_t nx_compat_time_now_ms(void);

// Sleep for specified milliseconds
void nx_compat_sleep_ms(int64_t ms);

// ============================================================================
// Compat Process Functions
// ============================================================================

// Exit the program with status code
void nx_compat_exit(int32_t code);

// Get environment variable
nx_string nx_compat_getenv(const char* name);

// Get command line arguments
nx_array nx_compat_args(void);

// Initialize command line arguments (call from main)
void nx_init_args(int argc, char** argv);

// ============================================================================
// Platform-Specific Functions
// ============================================================================

// Execute a system command (platform-specific)
int32_t nx_plat_system(const char* command);

#ifdef _WIN32
    #include <windows.h>
    #define PLATFORM_NAME "windows"
    #ifdef _WIN64
        #define PLATFORM_ARCH "x64"
    #else
        #define PLATFORM_ARCH "x86"
    #endif
#elif defined(__APPLE__)
    #include <unistd.h>
    #define PLATFORM_NAME "macos"
    #ifdef __aarch64__
        #define PLATFORM_ARCH "arm64"
    #else
        #define PLATFORM_ARCH "x64"
    #endif
#elif defined(__linux__)
    #include <unistd.h>
    #define PLATFORM_NAME "linux"
    #ifdef __x86_64__
        #define PLATFORM_ARCH "x64"
    #elif defined(__aarch64__)
        #define PLATFORM_ARCH "arm64"
    #else
        #define PLATFORM_ARCH "unknown"
    #endif
#else
    #define PLATFORM_NAME "unknown"
    #define PLATFORM_ARCH "unknown"
#endif

// Get platform name
const char* nx_plat_name(void);

// Get platform architecture
const char* nx_plat_arch(void);

#endif // NEXUS_CORE_H
